#include "game.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "gba.h"
#include "images/gameBoard.h"
#include "images/unselectedCard.h"
#include "images/selectedCard.h"
#include "images/openedCard1.h"
#include "images/openedCard2.h"
#include "images/matchedCard.h"
#include "images/titleScreen.h"

/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app.
typedef enum {
  RESET,
  START,
  SELECT,
  OPEN1,
  OPEN2,
  FLIP,
  MATCH,
  UNFLIP1,
  UNFLIP2,
  WIN,
} GBAState;

int main(void) {
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial game state
  GBAState state = RESET;

  while (1) {
    currentButtons = BUTTONS;  // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();
    if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
      state = RESET;
    }
    switch (state) {
      case RESET:
        state = START;
        resetState();
        break;
      case START:
        if (KEY_DOWN(BUTTON_START, currentButtons)) {
          state = SELECT;
          drawFullScreenImageDMA(gameBoard);
          drawCard(0, 0, selectedCard);
        }
        break;
      case SELECT:
        drawRectDMA(4, 4, 235, 8, INFO_BAR);
        drawString(4, 4, "Press A to flip a card...", WHITE);
        redrawCards(currentButtons, previousButtons);
        if (KEY_JUST_PRESSED(BUTTON_A, currentButtons, previousButtons) && flipCard()) {
          state = OPEN1;
        }
        break;
      case OPEN1:
        state = OPEN2;
        drawCard(flippedCards[flippedCardCount].row, flippedCards[flippedCardCount].col, openedCard1);
        wait(100000);
        break;
      case OPEN2:
        state = FLIP;
        drawCard(flippedCards[flippedCardCount].row, flippedCards[flippedCardCount].col, openedCard2);
        wait(100000);
        break;
      case FLIP:
        state = SELECT;
        drawFace(flippedCards[flippedCardCount]);
        flippedCardCount++;
        if (flippedCardCount >= 2) {
          if (flippedCards[0].value == flippedCards[1].value) {
            state = MATCH;
          } else {
            state = UNFLIP1;
          }
          flippedCardCount = 0;
        }
        break;
      case MATCH:
        state = SELECT;
        matchedPairs++;
        drawRectDMA(4, 4, 235, 8, INFO_BAR);
        drawString(4, 4, "You got a match!", WHITE);
        if (matchedPairs >= 9) {
          state = WIN;
          drawCard(flippedCards[1].row, flippedCards[1].col, matchedCard);
        }
        drawCard(flippedCards[0].row, flippedCards[0].col, matchedCard);
        for (int i = 0; i < 2; i++) {
          drawFace(flippedCards[i]);
          cards[OFFSET(flippedCards[i].row, flippedCards[i].col, 6)].isMatched = 1;
        }
        wait(300000);
        break;
      case UNFLIP1:
        state = UNFLIP2;
        drawRectDMA(4, 4, 235, 8, INFO_BAR);
        drawString(4, 4, "Oops, try again!", WHITE);
        for (int i = 0; i < 2; i++) {
          drawCard(flippedCards[i].row, flippedCards[i].col, unselectedCard);
          drawFace(flippedCards[i]);
        }
        wait(300000);
        break;
      case UNFLIP2:
        state = SELECT;
        drawCard(flippedCards[0].row, flippedCards[0].col, unselectedCard);
        drawCard(flippedCards[1].row, flippedCards[1].col, selectedCard);
        for (int i = 0; i < 2; i++) {
          cards[OFFSET(flippedCards[i].row, flippedCards[i].col, 6)].isFlipped = 0;
        }
        break;
      case WIN:
        drawRectDMA(4, 4, 235, 8, INFO_BAR);
        drawString(4, 4, "You win! Press SELECT to restart.", WHITE);
        break;
    }

    previousButtons = currentButtons;  // Store the current state of the buttons
  }

  return 0;
}

void resetState(void) {
  drawFullScreenImageDMA(titleScreen);
  cursor.row = 0;
  cursor.col = 0;
  initCards();
}

void initCards(void) {
  int values[18] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 0, 1, 2, 3, 4, 5, 6, 7, 8};
  int valRemaining = 17;
  flippedCardCount = 0;
  matchedPairs = 0;
  for (int r = 0; r < 3; r++) {
    for (int c = 0; c < 6; c++) {
      int randIndex = randint(0, valRemaining);
      int randVal = values[randIndex];
      values[randIndex] = values[valRemaining];
      valRemaining--;
      Card card = {
        .row = r,
        .col = c,
        .value = randVal,
        .isFlipped = 0
      };
      cards[OFFSET(r, c, 6)] = card;
    }
  }
}

void redrawCards(u32 currentButtons, u32 previousButtons) {
  cursor.prevRow = cursor.row;
  cursor.prevCol = cursor.col;
  if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons) && cursor.row > 0) {
    cursor.row--;
  }
  if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons) && cursor.row < 2) {
    cursor.row++;
  }
  if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons) && cursor.col > 0) {
    cursor.col--;
  }
  if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons) && cursor.col < 5) {
    cursor.col++;
  }
  if ((cursor.prevRow != cursor.row) || (cursor.prevCol != cursor.col)) {
    Card card = cards[OFFSET(cursor.prevRow, cursor.prevCol, 6)];
    if (card.isMatched) {
      drawCard(cursor.prevRow, cursor.prevCol, matchedCard);
      drawFace(card);
    } else if (!card.isFlipped) {
      drawCard(cursor.prevRow, cursor.prevCol, unselectedCard);
    }
    card = cards[OFFSET(cursor.row, cursor.col, 6)];
    if (card.isMatched) {
      drawCard(cursor.row, cursor.col, selectedCard);
      drawFace(card);
    } else if (!card.isFlipped) {
      drawCard(cursor.row, cursor.col, selectedCard);
    }
  }
}

int flipCard(void) {
  if (cards[OFFSET(cursor.row, cursor.col, 6)].isFlipped) {
    return 0;
  }
  flippedCards[flippedCardCount] = cards[OFFSET(cursor.row, cursor.col, 6)];
  cards[OFFSET(cursor.row, cursor.col, 6)].isFlipped = 1;
  return 1;
}

void drawCard(int row, int col, const u16 *image) {
  drawImageDMA(18 + row * 47, 4 + col * 39 + (col > 2), CARD_WIDTH, CARD_HEIGHT, image);
}

void drawFace(Card card) {
  drawImageDMA(21 + card.row * 47, 7 + card.col * 39 + (card.col > 2), 
                FACE_WIDTH, FACE_HEIGHT, faces[card.value]);
}

void wait(int count) {
  volatile int wait = 0;
  while(wait++ < count);
}